import React, { createContext, useContext, useReducer, useRef, useEffect, useCallback } from 'react';
import socketService from '../services/socketService';

// Audio State - th√™m h·ªó tr·ª£ pause/resume
const initialState = {
  isPlaying: false,
  audioEnabled: true, // Global audio toggle
  volume: 0.7,
  isMuted: false,
  userInteracted: false,
  isRefereeVoicePlaying: false, // Voice tr·ªçng t√†i ƒëang ph√°t
  isPaused: false, // Audio ƒëang b·ªã pause (kh√°c v·ªõi d·ª´ng ho√†n to√†n)
  currentAudioFile: null, // File audio hi·ªán t·∫°i
  pausedTime: 0, // Th·ªùi gian pause ƒë·ªÉ resume sau
};

// Audio Actions - th√™m pause/resume actions
const audioActions = {
  TOGGLE_AUDIO_ENABLED: 'TOGGLE_AUDIO_ENABLED',
  SET_AUDIO_ENABLED: 'SET_AUDIO_ENABLED',
  SET_VOLUME: 'SET_VOLUME',
  TOGGLE_MUTE: 'TOGGLE_MUTE',
  SET_PLAYING: 'SET_PLAYING',
  SET_USER_INTERACTED: 'SET_USER_INTERACTED',
  SET_REFEREE_VOICE_PLAYING: 'SET_REFEREE_VOICE_PLAYING',
  SET_PAUSED: 'SET_PAUSED',
  SET_CURRENT_AUDIO_FILE: 'SET_CURRENT_AUDIO_FILE',
  SET_PAUSED_TIME: 'SET_PAUSED_TIME',
};

// Audio Reducer - ƒë∆°n gi·∫£n h√≥a
const audioReducer = (state, action) => {
  switch (action.type) {
    case audioActions.TOGGLE_AUDIO_ENABLED:
      return {
        ...state,
        audioEnabled: !state.audioEnabled,
        isPlaying: state.audioEnabled ? false : state.isPlaying, // D·ª´ng audio n·∫øu t·∫Øt
      };
    case audioActions.SET_AUDIO_ENABLED:
      return {
        ...state,
        audioEnabled: action.payload,
        isPlaying: action.payload ? state.isPlaying : false, // D·ª´ng audio n·∫øu t·∫Øt
      };
    case audioActions.SET_VOLUME:
      return {
        ...state,
        volume: action.payload,
      };
    case audioActions.TOGGLE_MUTE:
      return {
        ...state,
        isMuted: !state.isMuted,
      };
    case audioActions.SET_PLAYING:
      return {
        ...state,
        isPlaying: action.payload,
      };
    case audioActions.SET_USER_INTERACTED:
      return {
        ...state,
        userInteracted: action.payload,
      };
    case audioActions.SET_REFEREE_VOICE_PLAYING:
      return {
        ...state,
        isRefereeVoicePlaying: action.payload,
      };
    case audioActions.SET_PAUSED:
      return {
        ...state,
        isPaused: action.payload,
      };
    case audioActions.SET_CURRENT_AUDIO_FILE:
      return {
        ...state,
        currentAudioFile: action.payload,
      };
    case audioActions.SET_PAUSED_TIME:
      return {
        ...state,
        pausedTime: action.payload,
      };
    default:
      return state;
  }
};

// Audio Context
const AudioContext = createContext();

// Audio Provider - ƒë∆°n gi·∫£n h√≥a
export const AudioProvider = ({ children }) => {
  const [state, dispatch] = useReducer(audioReducer, initialState);
  const audioRef = useRef(null);
  const refereeVoiceRef = useRef(null);

  // Static audio file mapping
  const audioFiles = {
    poster: '/audio/poster.mp3',
    rasan: '/audio/rasan.mp3',
    gialap: '/audio/gialap.mp3',
  };

  // Ph√°t voice tr·ªçng t√†i
  const playRefereeVoice = useCallback((audioBlob) => {
    console.log('üéôÔ∏è [AudioContext] Playing referee voice');

    // D·ª´ng t·∫•t c·∫£ audio kh√°c tr∆∞·ªõc
    stopCurrentAudio();

    try {
      // T·∫°o URL t·ª´ blob
      const audioUrl = URL.createObjectURL(audioBlob);
      const audio = new Audio(audioUrl);

      refereeVoiceRef.current = audio;
      audio.volume = state.isMuted ? 0 : state.volume;

      dispatch({ type: audioActions.SET_REFEREE_VOICE_PLAYING, payload: true });

      audio.onended = () => {
        console.log('‚úÖ Referee voice playback ended');
        dispatch({ type: audioActions.SET_REFEREE_VOICE_PLAYING, payload: false });
        URL.revokeObjectURL(audioUrl);
        refereeVoiceRef.current = null;
      };

      audio.onerror = (e) => {
        console.error('‚ùå Referee voice playback error:', e);
        dispatch({ type: audioActions.SET_REFEREE_VOICE_PLAYING, payload: false });
        URL.revokeObjectURL(audioUrl);
        refereeVoiceRef.current = null;
      };

      const playPromise = audio.play();
      if (playPromise) {
        playPromise
          .then(() => {
            console.log('‚úÖ Referee voice started playing successfully');
          })
          .catch((error) => {
            console.error('‚ùå Failed to play referee voice:', error);
            dispatch({ type: audioActions.SET_REFEREE_VOICE_PLAYING, payload: false });
            URL.revokeObjectURL(audioUrl);
            refereeVoiceRef.current = null;
          });
      }

    } catch (error) {
      console.error('‚ùå Error creating referee voice audio:', error);
      dispatch({ type: audioActions.SET_REFEREE_VOICE_PLAYING, payload: false });
    }
  }, [state.isMuted, state.volume]);

  // D·ª´ng voice tr·ªçng t√†i
  const stopRefereeVoice = useCallback(() => {
    console.log('üîá [AudioContext] Stopping referee voice');

    if (refereeVoiceRef.current) {
      try {
        refereeVoiceRef.current.pause();
        refereeVoiceRef.current.currentTime = 0;
        if (refereeVoiceRef.current.src && refereeVoiceRef.current.src.startsWith('blob:')) {
          URL.revokeObjectURL(refereeVoiceRef.current.src);
        }
      } catch (error) {
        console.warn('‚ö†Ô∏è Error stopping referee voice:', error);
      }
      refereeVoiceRef.current = null;
    }

    dispatch({ type: audioActions.SET_REFEREE_VOICE_PLAYING, payload: false });
  }, []);

  // Set up user interaction listeners
  useEffect(() => {
    const handleUserInteraction = () => {
      console.log('üéµ User interaction detected');
      dispatch({ type: audioActions.SET_USER_INTERACTED, payload: true });
      
      // Remove listeners after first interaction
      document.removeEventListener('click', handleUserInteraction);
      document.removeEventListener('keydown', handleUserInteraction);
      document.removeEventListener('touchstart', handleUserInteraction);
    };

    document.addEventListener('click', handleUserInteraction);
    document.addEventListener('keydown', handleUserInteraction);
    document.addEventListener('touchstart', handleUserInteraction);

    return () => {
      document.removeEventListener('click', handleUserInteraction);
      document.removeEventListener('keydown', handleUserInteraction);
      document.removeEventListener('touchstart', handleUserInteraction);
    };
  }, []);

  // Pause audio hi·ªán t·∫°i (l∆∞u v·ªã tr√≠ ƒë·ªÉ resume sau)
  const pauseCurrentAudio = useCallback(() => {
    console.log('‚è∏Ô∏è [AudioContext] Pausing current audio');

    if (audioRef.current && !audioRef.current.paused) {
      try {
        const currentTime = audioRef.current.currentTime;
        audioRef.current.pause();

        dispatch({ type: audioActions.SET_PLAYING, payload: false });
        dispatch({ type: audioActions.SET_PAUSED, payload: true });
        dispatch({ type: audioActions.SET_PAUSED_TIME, payload: currentTime });

        console.log('‚è∏Ô∏è [AudioContext] Audio paused at time:', currentTime);
      } catch (error) {
        console.warn('‚ö†Ô∏è Error pausing audio:', error);
      }
    }
  }, []);

  // Resume audio t·ª´ v·ªã tr√≠ ƒë√£ pause
  const resumeCurrentAudio = useCallback(() => {
    console.log('‚ñ∂Ô∏è [AudioContext] Resuming current audio');

    if (!state.audioEnabled) {
      console.log('üîá Audio disabled globally');
      return;
    }

    if (!state.userInteracted) {
      console.log('‚è≥ User hasn\'t interacted yet, skipping audio resume');
      return;
    }

    if (state.isRefereeVoicePlaying) {
      console.log('üéôÔ∏è Referee voice is playing, skipping audio resume');
      return;
    }

    if (audioRef.current && state.isPaused) {
      try {
        audioRef.current.currentTime = state.pausedTime;
        audioRef.current.volume = state.isMuted ? 0 : state.volume;

        const playPromise = audioRef.current.play();
        if (playPromise) {
          playPromise
            .then(() => {
              console.log('‚ñ∂Ô∏è Audio resumed successfully from time:', state.pausedTime);
              dispatch({ type: audioActions.SET_PLAYING, payload: true });
              dispatch({ type: audioActions.SET_PAUSED, payload: false });
            })
            .catch((error) => {
              console.error('‚ùå Failed to resume audio:', error);
              dispatch({ type: audioActions.SET_PLAYING, payload: false });
              dispatch({ type: audioActions.SET_PAUSED, payload: false });
            });
        }
      } catch (error) {
        console.error('‚ùå Error resuming audio:', error);
        dispatch({ type: audioActions.SET_PLAYING, payload: false });
        dispatch({ type: audioActions.SET_PAUSED, payload: false });
      }
    } else if (state.currentAudioFile && state.isPaused) {
      // N·∫øu audio element ƒë√£ b·ªã x√≥a, t·∫°o l·∫°i v√† ph√°t t·ª´ v·ªã tr√≠ pause
      console.log('üîÑ Recreating audio element and resuming from:', state.pausedTime);
      playAudioFromTime(state.currentAudioFile, state.pausedTime);
    }
  }, [state.audioEnabled, state.userInteracted, state.isMuted, state.volume, state.isRefereeVoicePlaying, state.isPaused, state.pausedTime, state.currentAudioFile]);

  // D·ª´ng t·∫•t c·∫£ audio ƒëang ph√°t - d·ª´ng ho√†n to√†n
  const stopCurrentAudio = useCallback(() => {
    console.log('üîá [AudioContext] Stopping all audio elements completely');

    // D·ª´ng audio c·ªßa AudioContext
    if (audioRef.current) {
      try {
        audioRef.current.pause();
        audioRef.current.currentTime = 0;
        audioRef.current.src = '';
      } catch (error) {
        console.warn('‚ö†Ô∏è Error stopping AudioContext audio:', error);
      }
      audioRef.current = null;
    }

    // D·ª´ng voice tr·ªçng t√†i
    if (refereeVoiceRef.current) {
      try {
        refereeVoiceRef.current.pause();
        refereeVoiceRef.current.currentTime = 0;
        if (refereeVoiceRef.current.src && refereeVoiceRef.current.src.startsWith('blob:')) {
          URL.revokeObjectURL(refereeVoiceRef.current.src);
        }
      } catch (error) {
        console.warn('‚ö†Ô∏è Error stopping referee voice:', error);
      }
      refereeVoiceRef.current = null;
    }

    // D·ª´ng T·∫§T C·∫¢ audio elements tr√™n trang
    try {
      const allAudioElements = document.querySelectorAll('audio');
      console.log(`üîá [AudioContext] Found ${allAudioElements.length} audio elements to stop`);

      allAudioElements.forEach((audio, index) => {
        try {
          if (!audio.paused) {
            console.log(`üîá [AudioContext] Stopping audio element ${index + 1}`);
            audio.pause();
            audio.currentTime = 0;
            audio.src = '';
            // X√≥a audio element kh·ªèi DOM ƒë·ªÉ tr√°nh r√≤ r·ªâ b·ªô nh·ªõ
            if (audio.parentNode) {
              audio.parentNode.removeChild(audio);
            }
          }
        } catch (error) {
          console.warn(`‚ö†Ô∏è Error stopping audio element ${index + 1}:`, error);
        }
      });
    } catch (error) {
      console.warn('‚ö†Ô∏è Error finding/stopping page audio elements:', error);
    }

    dispatch({ type: audioActions.SET_PLAYING, payload: false });
    dispatch({ type: audioActions.SET_PAUSED, payload: false });
    dispatch({ type: audioActions.SET_CURRENT_AUDIO_FILE, payload: null });
    dispatch({ type: audioActions.SET_PAUSED_TIME, payload: 0 });
    dispatch({ type: audioActions.SET_REFEREE_VOICE_PLAYING, payload: false });
  }, []);

  // Play audio t·ª´ th·ªùi gian c·ª• th·ªÉ
  const playAudioFromTime = useCallback((audioKey, startTime = 0) => {
    const audioFile = audioFiles[audioKey];
    if (!audioFile) {
      console.error('‚ùå Audio file not found:', audioKey);
      return;
    }

    // Stop current audio before playing new one
    stopCurrentAudio();

    try {
      console.log('üéµ Creating new audio element:', audioFile, 'starting from:', startTime);
      const audio = new Audio(audioFile);
      audioRef.current = audio;
      audio.volume = state.isMuted ? 0 : state.volume;
      audio.currentTime = startTime;

      dispatch({ type: audioActions.SET_PLAYING, payload: true });
      dispatch({ type: audioActions.SET_PAUSED, payload: false });
      dispatch({ type: audioActions.SET_CURRENT_AUDIO_FILE, payload: audioKey });
      dispatch({ type: audioActions.SET_PAUSED_TIME, payload: 0 });

      audio.onended = () => {
        console.log('‚úÖ Audio playback ended');
        dispatch({ type: audioActions.SET_PLAYING, payload: false });
        dispatch({ type: audioActions.SET_PAUSED, payload: false });
        dispatch({ type: audioActions.SET_CURRENT_AUDIO_FILE, payload: null });
      };

      audio.onerror = (e) => {
        console.error('‚ùå Audio playback error:', e);
        dispatch({ type: audioActions.SET_PLAYING, payload: false });
        dispatch({ type: audioActions.SET_PAUSED, payload: false });
        dispatch({ type: audioActions.SET_CURRENT_AUDIO_FILE, payload: null });
      };

      const playPromise = audio.play();
      if (playPromise) {
        playPromise
          .then(() => {
            console.log('‚úÖ Audio started playing successfully from time:', startTime);
          })
          .catch((error) => {
            console.error('‚ùå Failed to play audio:', error);
            dispatch({ type: audioActions.SET_PLAYING, payload: false });
            dispatch({ type: audioActions.SET_PAUSED, payload: false });
            dispatch({ type: audioActions.SET_CURRENT_AUDIO_FILE, payload: null });
          });
      }

    } catch (error) {
      console.error('‚ùå Error creating audio:', error);
      dispatch({ type: audioActions.SET_PLAYING, payload: false });
      dispatch({ type: audioActions.SET_PAUSED, payload: false });
      dispatch({ type: audioActions.SET_CURRENT_AUDIO_FILE, payload: null });
    }
  }, [state.isMuted, state.volume, stopCurrentAudio, audioFiles]);

  // Play audio - ƒë∆°n gi·∫£n h√≥a
  const playAudio = useCallback((audioKey) => {
    console.log('üéµ Play audio request:', { audioKey, audioEnabled: state.audioEnabled });

    if (!state.audioEnabled) {
      console.log('üîá Audio disabled globally');
      return;
    }

    if (!state.userInteracted) {
      console.log('‚è≥ User hasn\'t interacted yet, skipping audio');
      return;
    }

    // Kh√¥ng ph√°t audio kh√°c n·∫øu voice tr·ªçng t√†i ƒëang ph√°t
    if (state.isRefereeVoicePlaying) {
      console.log('üéôÔ∏è Referee voice is playing, skipping regular audio');
      return;
    }

    const audioFile = audioFiles[audioKey];
    if (!audioFile) {
      console.error('‚ùå Audio file not found:', audioKey);
      return;
    }

    // S·ª≠ d·ª•ng playAudioFromTime ƒëÔøΩÔøΩ b·∫Øt ƒë·∫ßu t·ª´ ƒëÔøΩÔøΩÔøΩu
    playAudioFromTime(audioKey, 0);
  }, [state.audioEnabled, state.userInteracted, state.isRefereeVoicePlaying, playAudioFromTime]);

  // Toggle audio to√†n c·ª•c - CH·ªà LOCAL, KH√îNG G·ª¨I SOCKET
  const toggleAudioEnabled = useCallback(() => {
    const wasEnabled = state.audioEnabled;
    const newState = !wasEnabled;

    console.log('üéµ Toggling LOCAL audio:', { wasEnabled, newState });

    dispatch({ type: audioActions.TOGGLE_AUDIO_ENABLED });

    // KH√îNG G·ª¨I SOCKET N·ªÆA - CH·ªà T√ÅC ƒê·ªòNG LOCAL
    // N·∫øu ƒëang t·ª´ enabled -> disabled, d·ª´ng ph√°t audio hi·ªán t·∫°i
    if (wasEnabled && audioRef.current) {
      stopCurrentAudio();
    }
  }, [state.audioEnabled, stopCurrentAudio]);

  // CH·ªà X·ª¨ L√ù REFEREE VOICE - ƒê·ª¢I SOCKET K·∫æT N·ªêI
  useEffect(() => {
    const handleAudioControl = (data) => {
      console.log('üì° [AudioContext] Received audio_control from server:', data);

      // CH·ªà X·ª¨ L√ù REFEREE VOICE
      if (data.command === 'PLAY_REFEREE_VOICE' && data.payload) {
        console.log('üì° [AudioContext] Server command: PLAY_REFEREE_VOICE');
        const { audioData, mimeType } = data.payload;

        try {
          // Chuy·ªÉn audioData t·ª´ array v·ªÅ Uint8Array
          const uint8Array = new Uint8Array(audioData);
          const audioBlob = new Blob([uint8Array], { type: mimeType || 'audio/webm' });
          playRefereeVoice(audioBlob);
        } catch (error) {
          console.error('‚ùå [AudioContext] Error processing referee voice data:', error);
        }
      }
    };

    // Ki·ªÉm tra socket connection tr∆∞·ªõc khi ƒëƒÉng k√Ω listener
    const registerListener = () => {
      const connectionStatus = socketService.getConnectionStatus();

      if (connectionStatus.isConnected && socketService.socket) {
        console.log('üì° [AudioContext] Socket connected, registering audio control listener');
        socketService.onAudioControl(handleAudioControl);
        return true;
      } else {
        console.log('üì° [AudioContext] Socket not ready yet, will retry...');
        return false;
      }
    };

    // Th·ª≠ ƒëƒÉng k√Ω ngay l·∫≠p t·ª©c
    if (!registerListener()) {
      // N·∫øu socket ch∆∞a s·∫µn s√†ng, ƒë·ª£i v√† th·ª≠ l·∫°i
      const retryInterval = setInterval(() => {
        if (registerListener()) {
          clearInterval(retryInterval);
        }
      }, 100); // Ki·ªÉm tra m·ªói 100ms

      // Cleanup interval n·∫øu component unmount tr∆∞·ªõc khi socket ready
      const timeoutId = setTimeout(() => {
        clearInterval(retryInterval);
        console.log('‚ö†Ô∏è [AudioContext] Timeout waiting for socket connection');
      }, 10000); // Timeout sau 10 gi√¢y

      return () => {
        clearInterval(retryInterval);
        clearTimeout(timeoutId);
        if (socketService.socket) {
          socketService.off('audio_control', handleAudioControl);
        }
      };
    }

    // Cleanup n·∫øu ƒë√£ ƒëƒÉng k√Ω th√†nh c√¥ng ngay l·∫≠p t·ª©c
    return () => {
      console.log('üì° [AudioContext] Unregistering audio control listener');
      if (socketService.socket) {
        socketService.off('audio_control', handleAudioControl);
      }
    };
  }, [playRefereeVoice]); // Th√™m dependency ƒë·ªÉ tr√°nh stale closure

  // Cleanup khi unmount
  useEffect(() => {
    return () => {
      console.log('üßπ Cleaning up AudioProvider');
      
      // Cleanup audio
      if (audioRef.current) {
        try {
          audioRef.current.pause();
          audioRef.current.onended = null;
          audioRef.current.onerror = null;
        } catch (error) {
          console.warn('‚ö†Ô∏è Error cleaning up audio:', error);
        }
        audioRef.current = null;
      }

      // Cleanup referee voice
      if (refereeVoiceRef.current) {
        try {
          refereeVoiceRef.current.pause();
          refereeVoiceRef.current.onended = null;
          refereeVoiceRef.current.onerror = null;
          if (refereeVoiceRef.current.src && refereeVoiceRef.current.src.startsWith('blob:')) {
            URL.revokeObjectURL(refereeVoiceRef.current.src);
          }
        } catch (error) {
          console.warn('‚ö†Ô∏è Error cleaning up referee voice:', error);
        }
        refereeVoiceRef.current = null;
      }
    };
  }, []);

  // Update volume khi state thay ƒë·ªïi
  useEffect(() => {
    if (audioRef.current) {
      const newVolume = state.isMuted ? 0 : state.volume;
      console.log('üîä Updating audio element volume:', newVolume);
      audioRef.current.volume = newVolume;
    }

    if (refereeVoiceRef.current) {
      const newVolume = state.isMuted ? 0 : state.volume;
      console.log('üîä Updating referee voice volume:', newVolume);
      refereeVoiceRef.current.volume = newVolume;
    }
  }, [state.volume, state.isMuted]);

  const value = {
    // State
    ...state,

    // Audio functions
    playAudio,
    stopCurrentAudio,
    pauseCurrentAudio,
    resumeCurrentAudio,
    toggleAudioEnabled,
    playRefereeVoice,
    stopRefereeVoice,
  };

  return (
    <AudioContext.Provider value={value}>
      {children}
    </AudioContext.Provider>
  );
};

// Hook ƒë·ªÉ s·ª≠ d·ª•ng AudioContext
export const useAudio = () => {
  const context = useContext(AudioContext);
  if (!context) {
    throw new Error('useAudio must be used within AudioProvider');
  }
  return context;
};

export default AudioContext;
